[{"name":"Listbox","comment":" Implementation of the [listbox\nwidget](https://www.w3.org/TR/wai-aria-practices-1.1/#Listbox):\n\n> A listbox widget presents a list of options and allows a user to select one\n> or more of them.\n\nTake a look at the documentation of `Behaviour` for the default keyboard\ninteractions this widget offers.\n\n@docs Listbox, init, view, Instance\n\n@docs Entry, option, divider\n\n@docs update, Msg, subscriptions\n\n\n# Configuration\n\n\n## Update\n\n@docs UpdateConfig, updateConfig, Behaviour\n\n\n## View\n\n@docs ViewConfig, viewConfig, Views, noDivider\n\n@docs HtmlAttributes, HtmlDetails\n\n\n## Type-ahead\n\n@docs TypeAhead, noTypeAhead, simpleTypeAhead, typeAhead\n\n\n# Advanced usage\n\n\n## State info\n\n@docs focusedEntry, hoveredEntry\n\n\n## State manipulation\n\n@docs focusEntry, focusNextOrFirstEntry, focusPreviousOrFirstEntry\n\n\n## DOM Stuff\n\n@docs focus\n\n@docs scrollToFocus\n\n@docs preventDefaultOnKeyDown\n\n\n## Using different DOM libraries\n\nYou can use these functions if you want to use other DOM libraries, like for\nexample `rtfeldman/elm-css` or `mdgriffith/elm-ui`.\n\n@docs customView, DomFunctions\n\n@docs CustomViewConfig, customViewConfig, CustomViews\n\n@docs customPreventDefaultOnKeyDown\n\n","unions":[],"aliases":[{"name":"Behaviour","comment":" **Available behaviour customizations**\n\nYou can customize the behaviour of the listbox with the following options:\n\n  - **jumpAtEnds**: Whether the keyboard focus should jump to the other end of\n    the list when pressing `ArrowUp` while focusing the first option (or\n    `ArrowDown` while focusing the last).\n\n  - **separateFocus**: Whether the mouse focus and the keyboard focus can be\n    different.\n\n  - **selectionFollowsFocus**: Do we automatically add the entry gaining\n    keyboard focus to the selection?\n\n  - **handleHomeAndEnd**: Should we handle the `Home` and `End` keys (to jump\n    to the top or bottom of the list)?\n\n  - **typeAhead**: Make it possible to jump to options by typing in a query.\n    Take a look at `TypeAhead` for more information.\n\n  - **minimalGap**: If the distance (in px) of the option having the keyboard\n    focus to the borders of the listbox's viewport is smaller then this value,\n    the listbox will adjust its scroll position so that this distance is at least\n    `initialGap`.\n\n  - **initialGap**: The minimal distance (in px) of the option having the\n    keyboard focus to the borders of the listbox's viewport after the scroll\n    position has been adjusted.\n\nA behaviour configuration could look something like this:\n\n    behaviour : Behaviour String\n    behaviour =\n        { jumpAtEnds = True\n        , separateFocus = True\n        , selectionFollowsFocus = False\n        , handleHomeAndEnd = True\n        , typeAhead = simpleTypeAhead 300 identity\n        , minimalGap = 30\n        , initialGap = 200\n        }\n\nThe listbox will behave as explained in the [WAI-ARIA Authoring Practices\n1.1](https://www.w3.org/TR/wai-aria-practices-1.1/#Listbox) in the _Keyboard\nInteraction_ section. Note that you get the _recommended selection model_ if\nyou choose `selectionFollowsFocus = False`, and the _alternative\nselection model_ for `selectionFollowsFocus = True`.\n\n","args":["a"],"type":"{ jumpAtEnds : Basics.Bool, separateFocus : Basics.Bool, selectionFollowsFocus : Basics.Bool, handleHomeAndEnd : Basics.Bool, typeAhead : Listbox.TypeAhead a, minimalGap : Basics.Float, initialGap : Basics.Float }"},{"name":"CustomViewConfig","comment":" ","args":["a","divider","attributeNever","htmlNever"],"type":"Internal.Listbox.ViewConfig a divider attributeNever htmlNever"},{"name":"CustomViews","comment":" A replacement for `Views` when you are using your own `customView`\nfunction. Take a look at its documentation for a description of each field.\n","args":["a","divider","attributeNever","htmlNever"],"type":"{ ul : List.List attributeNever, liOption : { selected : Basics.Bool, focused : Basics.Bool, hovered : Basics.Bool, maybeQuery : Maybe.Maybe String.String } -> a -> { attributes : List.List attributeNever, children : List.List htmlNever }, liDivider : divider -> { attributes : List.List attributeNever, children : List.List htmlNever }, empty : htmlNever, focusable : Basics.Bool }"},{"name":"DomFunctions","comment":" This record holds all the DOM functions needed to render a listbox. It is\nprobably instructive to look at the version for the standard `elm/html`\npackage:\n\n    htmlFunctions : DomFunctions (Attribute msg) (Attribute Never) (Html msg) (Html Never) msg\n    htmlFunctions =\n        { ul = Html.ul\n        , li = Html.li\n        , on = Events.on\n        , preventDefaultOn = Events.preventDefaultOn\n        , attribute = Attributes.attribute\n        , attributeMap = \\noOp -> Attributes.map (\\_ -> noOp)\n        , htmlMap = \\noOp -> Html.map (\\_ -> noOp)\n        }\n\nWhen using `mdgriffith/elm-ui`, you could define something like this:\n\n    elementFunctions : DomFunctions (Attribute msg) (Attribute Never) (Element msg) (Element Never) msg\n    elementFunctions =\n        { ul = Element.column\n        , li = Element.row\n        , on = Element.htmlAttribute (Events.on event decoder)\n        , preventDefaultOn = Element.htmlAttribute (Events.preventDefaultOn event decoder)\n        , attribute = Element.htmlAttribute (Attributes.attribute name value)\n        , attributeMap = \\noOp -> Element.mapAttribute (\\_ -> noOp)\n        , htmlMap = \\noOp -> Element.map (\\_ -> noOp)\n        }\n\n","args":["attribute","attributeNever","html","htmlNever","msg"],"type":"{ ul : List.List attribute -> List.List html -> html, li : List.List attribute -> List.List html -> html, on : String.String -> Json.Decode.Decoder msg -> attribute, preventDefaultOn : String.String -> Json.Decode.Decoder ( msg, Basics.Bool ) -> attribute, attribute : String.String -> String.String -> attribute, attributeMap : msg -> attributeNever -> attribute, htmlMap : msg -> htmlNever -> html }"},{"name":"Entry","comment":" When updating or viewing a listbox you have to provide a list of entries.\nThese can be selectable options or non-selectable dividers. You can construct\nthese using `option` and `divider`.\n","args":["a","divider"],"type":"Internal.Listbox.Entry a divider"},{"name":"HtmlAttributes","comment":" A list of attributes which never throw messages. Used to apply styling to\na DOM element.\n","args":[],"type":"List.List (Html.Attribute Basics.Never)"},{"name":"HtmlDetails","comment":" Used to apply styling and content to a DOM element.\n","args":[],"type":"{ attributes : List.List (Html.Attribute Basics.Never), children : List.List (Html.Html Basics.Never) }"},{"name":"Instance","comment":" To make a listbox unique in your application you have to provide this\ninformation to the `view` function:\n\n  - **id**: The unique id of the listbox.\n\n  - **labelledBy**: The unique id of a label element describing the content of\n    the listbox.\n\n  - **lift**: Your message type constructor wrapping the listbox `Msg`'s.\n\n","args":["a","msg"],"type":"{ id : String.String, labelledBy : String.String, lift : Listbox.Msg a -> msg }"},{"name":"Listbox","comment":" Tracks the keyboard and mouse focus as well as the current query. The full\nlist of entries and the currently selected option(s) live in your own model.\n","args":[],"type":"Internal.Listbox.Listbox"},{"name":"Msg","comment":" The listbox's message type.\n","args":["a"],"type":"Internal.Listbox.Msg a"},{"name":"TypeAhead","comment":" ","args":["a"],"type":"Internal.Listbox.TypeAhead a"},{"name":"UpdateConfig","comment":" ","args":["a"],"type":"Internal.Listbox.UpdateConfig a"},{"name":"ViewConfig","comment":" ","args":["a","divider"],"type":"Internal.Listbox.ViewConfig a divider (Html.Attribute Basics.Never) (Html.Html Basics.Never)"},{"name":"Views","comment":" **Available view customizations**\n\nThis is the second argument to `viewConfig`. You can customize the styling with\nthe following fields:\n\n  - **ul**: A list of html attributes applied to the outer listbox.\n\n  - **liOption**: A function returning `HtmlDetails` for each option in your\n    entries list. It gets the actual option value `a` and flags telling you if\n    this option is currently `selected`, `focused` or `hovered`. If the user\n    typed in a query, you get this via the `maybeQuery` field.\n\n  - **liDivider**: This lets you style the divider list entries. It gets the\n    actual `divider` entry and returns `HtmlDetails`.\n\n  - **empty**: What should be rendered when the listbox is empty?\n\n  - **focusable**: Should the listbox be focusable?\n\nThe DOM structure of a listbox will be something like this:\n\n    listbox =\n        Html.ul\n            [ ... ] -- ul attributes\n            [ Html.li\n                [ ... ] -- liDivider attributes\n                [ ... ] -- liDivider children\n            , Html.li\n                [ ... ] -- liOption attributes\n                [ ... ] -- liOption children\n            , ...\n            , Html.li\n                [ ... ] -- liOption attributes\n                [ ... ] -- liOption children\n            ]\n\nProvided you have specified some CSS classes, a view configuration could look\nlike this:\n\n    views : Views String Never\n    views =\n        { ul = [ Html.Attributes.class \"listbox__container\" ]\n        , liOption =\n            \\{ selected, focused } option ->\n                { attributes =\n                    [ Html.Attributes.class \"listbox__option\"\n                    , Html.Attributes.classList\n                        [ ( \"listbox__option--selected\"\n                          , selected\n                          )\n                        , ( \"listbox__option--keyboardFocused\"\n                          , focused\n                          )\n                        ]\n                    ]\n                , children =\n                    [ Html.text option ]\n                }\n        , liDivider = noDivider\n        , empty = Html.text \"\"\n        , focusable = True\n        }\n\n","args":["a","divider"],"type":"{ ul : Listbox.HtmlAttributes, liOption : { selected : Basics.Bool, focused : Basics.Bool, hovered : Basics.Bool, maybeQuery : Maybe.Maybe String.String } -> a -> Listbox.HtmlDetails, liDivider : divider -> Listbox.HtmlDetails, empty : Html.Html Basics.Never, focusable : Basics.Bool }"}],"values":[{"name":"customPreventDefaultOnKeyDown","comment":" A replacement for `preventDefaultOn` when you are using your own\n`customView` function.\n","type":"(String.String -> Json.Decode.Decoder ( msg, Basics.Bool ) -> attribute) -> Listbox.Instance a msg -> Json.Decode.Decoder ( msg, Basics.Bool ) -> attribute"},{"name":"customView","comment":" Create a customized view function for the DOM library of your choice by\nproviding some `DomFunctions`.\n","type":"Listbox.DomFunctions attribute attributeNever html htmlNever msg -> Listbox.CustomViewConfig a divider attributeNever htmlNever -> Listbox.Instance a msg -> List.List (Listbox.Entry a divider) -> Listbox.Listbox -> List.List a -> html"},{"name":"customViewConfig","comment":" A replacement for `viewConfig` when you are using your own `customView`\nfunction.\n","type":"(a -> String.String) -> Listbox.CustomViews a divider attributeNever htmlNever -> Listbox.CustomViewConfig a divider attributeNever htmlNever"},{"name":"divider","comment":" Create a non-selectable divider.\n","type":"divider -> Listbox.Entry a divider"},{"name":"focus","comment":" A task to give the listbox focus. The first argument must match the\n`Instance` used in the `view` function!\n","type":"Listbox.Instance a msg -> Task.Task Browser.Dom.Error ()"},{"name":"focusEntry","comment":" Sets the keyboard focus to the provided options.\n\n**Note**: This will not adjust the scroll position of the listbox, so you might\nwant to apply `scrollToFocus` afterwards.\n\n","type":"Listbox.UpdateConfig a -> a -> Listbox.Listbox -> List.List a -> ( Listbox.Listbox, List.List a )"},{"name":"focusNextOrFirstEntry","comment":" Sets the keyboard focus to the next option. If `jumpAtEnds` is true and the\nfocus is already on the last option, the first option is selected.\n\n**Note**: This will not adjust the scroll position of the listbox, so you might\nwant to apply `scrollToFocus` afterwards.\n\n","type":"Listbox.UpdateConfig a -> List.List (Listbox.Entry a divider) -> Listbox.Listbox -> List.List a -> ( Listbox.Listbox, List.List a )"},{"name":"focusPreviousOrFirstEntry","comment":" Sets the keyboard focus to the previous option. If `jumpAtEnds` is true and the\nfocus is already on the first option, the first option is selected.\n\n**Note**: This will not adjust the scroll position of the listbox, so you might\nwant to apply `scrollToFocus` afterwards.\n\n","type":"Listbox.UpdateConfig a -> List.List (Listbox.Entry a divider) -> Listbox.Listbox -> List.List a -> ( Listbox.Listbox, List.List a )"},{"name":"focusedEntry","comment":" Returns the option which currently has keyboard focus.\n","type":"Listbox.UpdateConfig a -> List.List (Listbox.Entry a divider) -> Listbox.Listbox -> Maybe.Maybe a"},{"name":"hoveredEntry","comment":" Returns the option which currently has mouse focus.\n","type":"Listbox.UpdateConfig a -> List.List (Listbox.Entry a divider) -> Listbox.Listbox -> Maybe.Maybe a"},{"name":"init","comment":" An initial listbox with no option focused.\n","type":"Listbox.Listbox"},{"name":"noDivider","comment":" Helper function which can be used for the `liDivider` field in your view\ncustomizations if you do not have any dividers in your listbox.\n","type":"Basics.Never -> Listbox.HtmlDetails"},{"name":"noTypeAhead","comment":" Use this inside `Behaviour` if you do not want to activate the type-ahead\nfunctionality.\n","type":"Listbox.TypeAhead a"},{"name":"option","comment":" Create a selectable option.\n","type":"a -> Listbox.Entry a divider"},{"name":"preventDefaultOnKeyDown","comment":" This adds all the keydown event listener needed for the listbox on any DOM\nnode. For example, this could be an input field which keeps focused while the\nlistbox is displayed in a dropdown. You usually want to set `focusable = False`\ninside the `ViewConfig` when using this event listener.\n\nYou must provide your own event decoder, which is tried **before** the\nlistbox's event decoder. This lets you prevent the listbox reacting on key\ncombinations. If you do not need to handle keydown events, just insert a failing decoder:\n\n    view =\n        Html.input\n            [ preventDefaultOnKeyDown\n                { id = \"fruits-listbox\"\n                , labelledBy = \"fruits\"\n                , lift = ListboxMsg\n                }\n                (Decode.fail \"not handling this event here\")\n            ]\n            []\n\nIn this example, pressing keys like `ArrowUp` and `ArrowDown` will adjust the\nlistbox's focus although the listbox itself is not focused.\n\n","type":"Listbox.Instance a msg -> Json.Decode.Decoder ( msg, Basics.Bool ) -> Html.Attribute msg"},{"name":"scrollToFocus","comment":" A command adjusting the scroll position of the listbox such that the\ncurrent keyboard focus is visible.\n","type":"Listbox.Behaviour a -> Listbox.Instance a msg -> Listbox.Listbox -> Platform.Cmd.Cmd msg"},{"name":"simpleTypeAhead","comment":" Activate the type-ahead functionality. When the user types in a search\nquery.\n\n  - The first argument is the timeout (in milliseconds) after which the query\n    is reseted.\n\n  - The second argument, `a -> String`, should be a reasonable stringification\n    of the options. It is used to check whether an option starts with this query\n    or not. The listbox will then move the keyboard focus forward to the next\n    matching option.\n\n","type":"Basics.Int -> (a -> String.String) -> Listbox.TypeAhead a"},{"name":"subscriptions","comment":" Do not forget to add this to your subscriptions:\n\n    subscriptions model =\n        Sub.map ListboxMsg\n            (Listbox.subscriptions model.listbox)\n\n","type":"Listbox.Listbox -> Platform.Sub.Sub (Listbox.Msg a)"},{"name":"typeAhead","comment":" This works like `simpleTypeAhead` but gives you you more flexibility when\ncustomizing the matching condition. The first argument is the timeout. The\nsecond argument is a function which gets the current query and an option,\nreturning if the query matches this option.\n","type":"Basics.Int -> (String.String -> a -> Basics.Bool) -> Listbox.TypeAhead a"},{"name":"update","comment":" Use this function to update the listbox state. You have to provide the same\nentries and selection as given to your view function.\n\nFor example:\n\n    update msg model =\n        case msg of\n            ListboxMsg listboxMsg ->\n                let\n                    ( newListbox, listboxCmd, newSelection ) =\n                        Listbox.update updateConfig\n                            entries\n                            listboxMsg\n                            model.listbox\n                            model.selection\n                in\n                ( { model\n                    | listbox = newListbox\n                    , selection = newSelection\n                  }\n                , Cmd.map ListboxMsg listboxCmd\n                )\n\nIn a more sophisticated example, the entries could be dynamic, as well. (For\nexample, loaded via an HTTP request.)\n\n","type":"Listbox.UpdateConfig a -> List.List (Listbox.Entry a divider) -> Listbox.Msg a -> Listbox.Listbox -> List.List a -> ( Listbox.Listbox, Platform.Cmd.Cmd (Listbox.Msg a), List.List a )"},{"name":"updateConfig","comment":" Generate an `UpdateConfig` by providing a hash function for the entries and\na `Behaviour` record.\n","type":"(a -> String.String) -> Listbox.Behaviour a -> Listbox.UpdateConfig a"},{"name":"view","comment":" Take a list of all entries and a list of selected options and display it as\na listbox. You have to provide a `ViewConfig` for the styling and an `Instance`\nto uniquely identify this listbox. For example:\n\n    view : Listbox -> List String -> Html Msg\n    view listbox selection =\n        Html.div []\n            [ Listbox.view viewConfig\n                { id = \"fruits-listbox\"\n                , labelledBy = \"fruits\"\n                , lift = ListboxMsg\n                }\n                fruits\n                listbox\n                selection\n            ]\n\n    fruits : List (Entry String divider)\n    fruits =\n        List.map Listbox.option\n            [ \"Apple\", \"Banana\", \"Cherry\" ]\n\n    type Msg\n        = ListboxMsg Listbox.Msg\n\n","type":"Listbox.ViewConfig a divider -> Listbox.Instance a msg -> List.List (Listbox.Entry a divider) -> Listbox.Listbox -> List.List a -> Html.Html msg"},{"name":"viewConfig","comment":" Generate a `ViewConfig` by providing a hash function for the entries and\na `Views` record, which holds all the styling information. You usually do\n**not** want to store this inside your model.\n","type":"(a -> String.String) -> Listbox.Views a divider -> Listbox.ViewConfig a divider"}],"binops":[]},{"name":"Listbox.Dropdown","comment":" This is a collapsible dropdown version of `Listbox`. The behaviour\nis based on the [Collapsible Dropdown Listbox\nExample](https://www.w3.org/TR/wai-aria-practices-1.1/examples/listbox/listbox-collapsible.html).\n\n@docs Dropdown, init, view, Instance\n\n@docs update, Msg, subscriptions\n\n\n# Configuration\n\n@docs UpdateConfig, updateConfig, Behaviour\n\n@docs ViewConfig, viewConfig, Views\n\n\n# Using different DOM libraries\n\n@docs customView, DomFunctions\n\n@docs CustomViewConfig, customViewConfig, CustomViews\n\n","unions":[{"name":"CustomViewConfig","comment":" ","args":["a","divider","attributeNever","htmlNever"],"cases":[["CustomViewConfig",["a -> String.String","Listbox.Dropdown.CustomViews a divider attributeNever htmlNever"]]]},{"name":"Dropdown","comment":" Tracks the keyboard and mouse focus as well as the current query and\nwhether the dropdown is open or closed. The full list of entries and the\ncurrently selected option(s) live in your own model.\n","args":[],"cases":[]},{"name":"Msg","comment":" The dropdown's message type.\n","args":["a"],"cases":[]},{"name":"UpdateConfig","comment":" ","args":["a"],"cases":[]},{"name":"ViewConfig","comment":" ","args":["a","divider"],"cases":[]}],"aliases":[{"name":"Behaviour","comment":" **Available behaviour customizations**\n\nYou can customize the behaviour of the dropdown with the following options:\n\n  - **jumpAtEnds**: Should the keyboard focus jump to the other end of the list\n    when pressing `ArrowUp` while focusing the first option (or `ArrowDown` while\n    focusing the last).\n\n  - **closeAfterMouseSelection**: Should the dropdown be hidden after the user\n    selected an option with the mouse?\n\n  - **separateFocus**: Whether the mouse focus and the keyboard focus can be\n    different.\n\n  - **selectionFollowsFocus**: Do we automatically select the entry gaining\n    keyboard focus?\n\n  - **handleHomeAndEnd**: Should we handle the `Home` and `End` keys (to jump\n    to the top or bottom of the list)?\n\n  - **typeAhead**: Make it possible to jump to options by typing in a query.\n    Take a look at `TypeAhead` for more information.\n\n  - **minimalGap**: If the distance (in px) of the option having the keyboard\n    focus to the borders of the listbox scene is smaller then this value, the\n    listbox will adjust its scroll position so that this distance is at least\n    `initialGap`.\n\n  - **initialGap**: The minimal distance (in px) of the option having the\n    keyboard focus to the borders of the listbox scene after the scroll position\n    has been adjusted.\n\nA behaviour configuration could look something like this:\n\n    behaviour : Behaviour String\n    behaviour =\n        { jumpAtEnds = True\n        , closeAfterMouseSelection = False\n        , separateFocus = True\n        , selectionFollowsFocus = False\n        , handleHomeAndEnd = True\n        , typeAhead = simpleTypeAhead 300 identity\n        , minimalGap = 30\n        , initialGap = 200\n        }\n\nThe dropdown will behave as explained in the [WAI-ARIA Authoring Practices\n1.1](https://www.w3.org/TR/wai-aria-practices-1.1/examples/listbox/listbox-collapsible.html)\nin the section _Keyboard Support_.\n\n","args":["a"],"type":"{ jumpAtEnds : Basics.Bool, closeAfterMouseSelection : Basics.Bool, separateFocus : Basics.Bool, selectionFollowsFocus : Basics.Bool, handleHomeAndEnd : Basics.Bool, typeAhead : Listbox.TypeAhead a, minimalGap : Basics.Float, initialGap : Basics.Float }"},{"name":"CustomViews","comment":" A replacement for `Views` when you are using your own `customView`\nfunction. Take a look at its documentation for a description of each field.\n","args":["a","divider","attributeNever","htmlNever"],"type":"{ container : List.List attributeNever, button : { maybeSelection : Maybe.Maybe a, open : Basics.Bool } -> { attributes : List.List attributeNever, children : List.List htmlNever }, ul : List.List attributeNever, liOption : { selected : Basics.Bool, focused : Basics.Bool, hovered : Basics.Bool, maybeQuery : Maybe.Maybe String.String } -> a -> { attributes : List.List attributeNever, children : List.List htmlNever }, liDivider : divider -> { attributes : List.List attributeNever, children : List.List htmlNever } }"},{"name":"DomFunctions","comment":" This record holds all the DOM functions needed to render a listbox. It is\nprobably instructive to look at the version for the standard `elm/html`\npackage:\n\n    htmlFunctions : DomFunctions (Attribute msg) (Attribute Never) (Html msg) (Html Never) msg\n    htmlFunctions =\n        { div =\n            \\attributes { button, ul } ->\n                Html.div attributes\n                    [ button\n                    , ul\n                    ]\n        , text = Html.text\n        , button = Html.button\n        , ul = Html.ul\n        , li = Html.li\n        , on = Events.on\n        , preventDefaultOn = Events.preventDefaultOn\n        , attribute = Attributes.attribute\n        , style = Attributes.style\n        , attributeMap = \\noOp -> Attributes.map (\\_ -> noOp)\n        , htmlMap = \\noOp -> Html.map (\\_ -> noOp)\n        }\n\nWhen using `mdgriffith/elm-ui`, you could define something like this:\n\n    elementFunctions : DomFunctions (Attribute msg) (Attribute Never) (Element msg) (Element Never) msg\n    elementFunctions =\n        { div =\n            \\attributes children ->\n                Element.el (Element.below children.ul :: attributes) children.button\n        , text = Element.text\n        , button =\n            \\attributes children ->\n                Input.button attributes\n                    { onPress = Nothing\n                    , label =\n                        Element.row\n                            [ Element.width Element.fill\n                            , Element.height Element.fill\n                            ]\n                            children\n                    }\n        , ul = Element.column\n        , li = Element.row\n        , on = Element.htmlAttribute (Events.on event decoder)\n        , preventDefaultOn = Element.htmlAttribute (Events.preventDefaultOn event decoder)\n        , attribute = Element.htmlAttribute (Attributes.attribute name value)\n        , style = Element.htmlAttribute (Attributes.style name value)\n        , attributeMap = \\noOp -> Element.mapAttribute (\\_ -> noOp)\n        , htmlMap = \\noOp -> Element.map (\\_ -> noOp)\n        }\n\n","args":["attribute","attributeNever","html","htmlNever","msg"],"type":"{ div : List.List attribute -> { button : html, ul : html } -> html, text : String.String -> htmlNever, button : List.List attribute -> List.List html -> html, ul : List.List attribute -> List.List html -> html, li : List.List attribute -> List.List html -> html, on : String.String -> Json.Decode.Decoder msg -> attribute, preventDefaultOn : String.String -> Json.Decode.Decoder ( msg, Basics.Bool ) -> attribute, attribute : String.String -> String.String -> attribute, style : String.String -> String.String -> attributeNever, attributeMap : msg -> attributeNever -> attribute, htmlMap : msg -> htmlNever -> html }"},{"name":"Instance","comment":" To make a dropdown listbox unique in your application you have to provide\nthis information to the `view` function:\n\n  - **id**: The unique id of the listbox.\n\n  - **labelledBy**: The unique id of a label element describing the content of\n    the listbox.\n\n","args":["msg","a"],"type":"{ id : String.String, labelledBy : String.String, lift : Listbox.Dropdown.Msg a -> msg }"},{"name":"Views","comment":" **Available view customizations**\n\nThis is the second argument to `viewConfig`. You can customize the styling with\nthe following fields:\n\n  - **container**: A list of html attributes applied to the container div which\n    holds the button and the listbox.\n\n  - **button**: A function which returns `HtmlDetails` for the button which\n    shows the current selection and toggles the visibility of the listbox. The\n    function gets as arguments the current selection and whether the listbox is\n    visible or not.\n\n  - **ul**: A list of html attributes applied to the outer listbox.\n\n  - **liOption**: A function which returns `HtmlDetails` for each option in\n    your entries list. It gets the actual option value `a` and flags telling you\n    if this option is currently `selected` or has focus (`keyboardFocus` and\n    `mouseFocus`). If the user typed in a query, you get this via the\n    `maybeQuery` field.\n\n  - **liDivider**: This lets you style the divider list entries. It gets the\n    actual `divider` entry and returns `HtmlDetails`.\n\nThe DOM structure of a dropdown will be something like this:\n\n    listbox =\n        Html.div\n            [ ... ] -- container attributes\n            [ Html.button\n                [ ... ] -- button attributes\n            , Html.ul\n                [ ... ] -- ul attributes\n                [ Html.li\n                    [ ... ] -- liDivider attributes\n                    [ ... ] -- liDivider children\n                , Html.li\n                    [ ... ] -- liOption attributes\n                    [ ... ] -- liOption children\n                , ...\n                , Html.li\n                    [ ... ] -- liOption attributes\n                    [ ... ] -- liOption children\n                ]\n            ]\n\nProvided you have specified some CSS classes, a view configuration could look\nlike this:\n\n    views : Views String Never\n    views =\n        { container = [ Html.Attributes.class \"dropdown__container\" ]\n        , button =\n            \\{ maybeSelection } ->\n                { attributes =\n                    [ Html.Attributes.class \"dropdown__button\" ]\n                , children =\n                    [ Html.text <|\n                        Maybe.withDefault \"Make a selection..\"\n                            maybeSelection\n                    ]\n                }\n        , ul = [ Html.Attributes.class \"listbox__container\" ]\n        , liOption =\n            \\{ selected, focused } option ->\n                { attributes =\n                    [ Html.Attributes.class \"listbox__option\"\n                    , Html.Attributes.classList\n                        [ ( \"listbox__option--selected\"\n                          , selected\n                          )\n                        , ( \"listbox__option--keyboardFocused\"\n                          , focused\n                          )\n                        ]\n                    ]\n                , children =\n                    [ Html.text option ]\n                }\n        , liDivider = noDivider\n        }\n\n","args":["a","divider"],"type":"{ container : Listbox.HtmlAttributes, button : { maybeSelection : Maybe.Maybe a, open : Basics.Bool } -> Listbox.HtmlDetails, ul : Listbox.HtmlAttributes, liOption : { selected : Basics.Bool, focused : Basics.Bool, hovered : Basics.Bool, maybeQuery : Maybe.Maybe String.String } -> a -> Listbox.HtmlDetails, liDivider : divider -> Listbox.HtmlDetails }"}],"values":[{"name":"customView","comment":" Create a customized view function for the DOM library of your choice by\nproviding some `DomFunctions`.\n","type":"Listbox.Dropdown.DomFunctions attribute attributeNever html htmlNever msg -> Listbox.Dropdown.CustomViewConfig a divider attributeNever htmlNever -> Listbox.Dropdown.Instance msg a -> List.List (Listbox.Entry a divider) -> Listbox.Dropdown.Dropdown -> Maybe.Maybe a -> html"},{"name":"customViewConfig","comment":" A replacement for `Views` when you are using your own `customView`\nfunction. Take a look at its documentation for a description of each field.\n","type":"(a -> String.String) -> Listbox.Dropdown.CustomViews a divider attributeNever htmlNever -> Listbox.Dropdown.CustomViewConfig a divider attributeNever htmlNever"},{"name":"init","comment":" An initial dropdown with no option focused, and which is closed.\n","type":"Listbox.Dropdown.Dropdown"},{"name":"subscriptions","comment":" Do not forget to add this to your subscriptions:\n\n    subscriptions model =\n        Sub.map DropdownMsg\n            (Listbox.Dropdown.subscriptions model.dropdown)\n\n","type":"Listbox.Dropdown.Dropdown -> Platform.Sub.Sub (Listbox.Dropdown.Msg a)"},{"name":"update","comment":" Use this function to update the dropdown state. You have to provide the\nsame entries and selection as to your view function.\n\nFor example:\n\n    update msg model =\n        case msg of\n            DropdownMsg dropdownMsg ->\n                let\n                    ( newDropdown, dropdownCmd, newSelection ) =\n                        Listbox.Dropdown.update updateConfig\n                            entries\n                            dropdownMsg\n                            model.dropdown\n                            model.selection\n                in\n                ( { model\n                    | dropdown = newDropdown\n                    , selection = newSelection\n                  }\n                , Cmd.map DropdownMsg dropdownCmd\n                )\n\nIn a more sofisticated example, the entries could be dynamic, as well. (For\nexample, loaded via an HTTP request.)\n\n","type":"Listbox.Dropdown.UpdateConfig a -> List.List (Listbox.Entry a divider) -> Listbox.Dropdown.Msg a -> Listbox.Dropdown.Dropdown -> Maybe.Maybe a -> ( Listbox.Dropdown.Dropdown, Platform.Cmd.Cmd (Listbox.Dropdown.Msg a), Maybe.Maybe a )"},{"name":"updateConfig","comment":" Generate an `UpdateConfig` by providing a hash function for the entries and\na `Behaviour` record.\n","type":"(a -> String.String) -> Listbox.Dropdown.Behaviour a -> Listbox.Dropdown.UpdateConfig a"},{"name":"view","comment":" Take a list of all entries and a list of selected options and display it as\na dropdown. You have to provide a `ViewConfig` for the styling and an\n`Instance` to uniquely identify this listbox. For example:\n\n    view : Dropdown -> Maybe String -> Html Msg\n    view dropdown selection =\n        Html.div []\n            [ Html.map DropdownMsg <|\n                Listbox.Dropdown.view viewConfig\n                    { id = \"fruits-dropdown\"\n                    , labelledBy = \"fruits\"\n                    }\n                    fruits\n                    dropdown\n                    selection\n            ]\n\n    fruits : List (Entry String divider)\n    fruits =\n        List.map Listbox.option\n            [ \"Apple\", \"Banana\", \"Cherry\" ]\n\n    type Msg\n        = DropdownMsg Listbox.Dropdown.Msg\n\n","type":"Listbox.Dropdown.ViewConfig a divider -> Listbox.Dropdown.Instance msg a -> List.List (Listbox.Entry a divider) -> Listbox.Dropdown.Dropdown -> Maybe.Maybe a -> Html.Html msg"},{"name":"viewConfig","comment":" Generate a `ViewConfig` by providing a hash function for the entries and\na `Views` record, which holds all the styling information. You usually do\n**not** want to store this inside your model.\n","type":"(a -> String.String) -> Listbox.Dropdown.Views a divider -> Listbox.Dropdown.ViewConfig a divider"}],"binops":[]},{"name":"Listbox.Unique","comment":" This is a variant of `Listbox` allowing only **at most one**\nselection. You just have to replace the `view` and the `update` function with\nthe ones in this module.\n\n@docs view, update\n\n@docs focusEntry, focusNextOrFirstEntry, focusPreviousOrFirstEntry\n\n@docs customView\n\n","unions":[],"aliases":[],"values":[{"name":"customView","comment":" Use this instead of `Listbox.customView` if the user can only select **at\nmost one** entry in the listbox. The only difference between the type signature\nof this function and the one of `Listbox.customView` is that the last argument\nis a `Maybe a` instead of a `List a`.\n","type":"Internal.Listbox.DomFunctions attribute attributeNever html htmlNever msg -> Listbox.CustomViewConfig a divider attributeNever htmlNever -> { id : String.String, labelledBy : String.String, lift : Listbox.Msg a -> msg } -> List.List (Listbox.Entry a divider) -> Listbox.Listbox -> Maybe.Maybe a -> html"},{"name":"focusEntry","comment":" Sets the keyboard focus to the provided options.\n\n**Note**: This will not adjust the scroll position of the listbox, so you might\nwant to apply `scrollToFocus` afterwards.\n\n","type":"Listbox.UpdateConfig a -> a -> Listbox.Listbox -> Maybe.Maybe a -> ( Listbox.Listbox, Maybe.Maybe a )"},{"name":"focusNextOrFirstEntry","comment":" Sets the keyboard focus to the next option. If `jumpAtEnds` is true and the\nfocus is already on the last option, the first option is selected.\n\n**Note**: This will not adjust the scroll position of the listbox, so you might\nwant to apply `scrollToFocus` afterwards.\n\n","type":"Listbox.UpdateConfig a -> List.List (Listbox.Entry a divider) -> Listbox.Listbox -> Maybe.Maybe a -> ( Listbox.Listbox, Maybe.Maybe a )"},{"name":"focusPreviousOrFirstEntry","comment":" Sets the keyboard focus to the previous option. If `jumpAtEnds` is true and the\nfocus is already on the first option, the first option is selected.\n\n**Note**: This will not adjust the scroll position of the listbox, so you might\nwant to apply `scrollToFocus` afterwards.\n\n","type":"Listbox.UpdateConfig a -> List.List (Listbox.Entry a divider) -> Listbox.Listbox -> Maybe.Maybe a -> ( Listbox.Listbox, Maybe.Maybe a )"},{"name":"update","comment":" Use this function instead of `Listbox.update` if the user can only\nselect **at most one** entry in the listbox. The only difference between the\ntype signature of this function and the one of `Listbox.update` is that the\nlast argument is a `Maybe a` instead of a `List a`.\n","type":"Listbox.UpdateConfig a -> List.List (Listbox.Entry a divider) -> Listbox.Msg a -> Listbox.Listbox -> Maybe.Maybe a -> ( Listbox.Listbox, Platform.Cmd.Cmd (Listbox.Msg a), Maybe.Maybe a )"},{"name":"view","comment":" Use this instead of `Listbox.view` if the user can only select **at\nmost one** entry in the listbox. The only difference between the type signature\nof this function and the one of `Listbox.view` is that the last argument is\na `Maybe a` instead of a `List a`.\n","type":"Listbox.ViewConfig a divider -> { id : String.String, labelledBy : String.String, lift : Listbox.Msg a -> msg } -> List.List (Listbox.Entry a divider) -> Listbox.Listbox -> Maybe.Maybe a -> Html.Html msg"}],"binops":[]}]